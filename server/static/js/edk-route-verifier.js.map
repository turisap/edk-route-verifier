{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/_baseIteratee.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/loglevel/lib/loglevel.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./src/lodash.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/_baseIsEqual.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/_baseMap.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_matchesStrictComparable.js","webpack:///./node_modules/lodash/_isStrictComparable.js","webpack:///./node_modules/lodash/_arrayFilter.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_equalArrays.js","webpack:///./node_modules/lodash/_Stack.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_getTag.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./src/helpers.js","webpack:///./node_modules/geojson-rbush/index.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/flatten/main.es.js","webpack:///./node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/distance/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/distance/main.es.js","webpack:///./node_modules/@turf/bearing/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/bearing/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/distance/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/destination/index.js","webpack:///./node_modules/@turf/line-segment/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/line-segment/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/line-segment/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/line-segment/index.js","webpack:///./node_modules/@turf/line-intersect/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/line-intersect/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/line-intersect/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/line-intersect/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/point-on-line/index.js","webpack:///./src/Controls.js","webpack:///./src/Context.js","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/meta/index.js","webpack:///./node_modules/quickselect/index.js","webpack:///./node_modules/rbush/index.js","webpack:///./src/Stations.js","webpack:///./src/PathElevation.js","webpack:///./src/Route.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_compareAscending.js","webpack:///./node_modules/lodash/_compareMultiple.js","webpack:///./node_modules/lodash/_baseSortBy.js","webpack:///./node_modules/lodash/_baseOrderBy.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/sortBy.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/map.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/find.js","webpack:///./node_modules/lodash/_basePropertyDeep.js","webpack:///./node_modules/lodash/_baseProperty.js","webpack:///./node_modules/lodash/property.js","webpack:///./node_modules/lodash/_hasPath.js","webpack:///./node_modules/lodash/_baseHasIn.js","webpack:///./node_modules/lodash/hasIn.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_baseMatchesProperty.js","webpack:///./node_modules/lodash/_getMatchData.js","webpack:///./node_modules/lodash/_baseIsMatch.js","webpack:///./node_modules/lodash/_baseMatches.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFilter.js","webpack:///./node_modules/lodash/filter.js","webpack:///./node_modules/lodash/isNull.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///./node_modules/lodash/stubArray.js","webpack:///./node_modules/lodash/_getSymbols.js","webpack:///./node_modules/lodash/_baseGetAllKeys.js","webpack:///./node_modules/lodash/_getAllKeys.js","webpack:///./node_modules/lodash/_equalObjects.js","webpack:///./node_modules/lodash/_setToArray.js","webpack:///./node_modules/lodash/_mapToArray.js","webpack:///./node_modules/lodash/_Uint8Array.js","webpack:///./node_modules/lodash/_equalByTag.js","webpack:///./node_modules/lodash/_cacheHas.js","webpack:///./node_modules/lodash/_arraySome.js","webpack:///./node_modules/lodash/_setCacheHas.js","webpack:///./node_modules/lodash/_setCacheAdd.js","webpack:///./node_modules/lodash/_SetCache.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_stackSet.js","webpack:///./node_modules/lodash/_stackHas.js","webpack:///./node_modules/lodash/_stackGet.js","webpack:///./node_modules/lodash/_stackDelete.js","webpack:///./node_modules/lodash/_stackClear.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_baseIsEqualDeep.js","webpack:///./node_modules/lodash/isEqual.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/_WeakMap.js","webpack:///./node_modules/lodash/_Set.js","webpack:///./node_modules/lodash/_Promise.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///./node_modules/lodash/_DataView.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/lodash/isEmpty.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/togeojson/togeojson.js","webpack:///./src/routeVerifier.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isArray","Array","freeGlobal","freeSelf","self","root","Function","baseIsNative","getValue","key","undefined","baseGetTag","isObjectLike","symbolTag","isFunction","isLength","length","baseMatches","baseMatchesProperty","identity","type","Symbol","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","toStringTag","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","bind","e","apply","arguments","replaceLoggingMethods","level","loggerName","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","factory","currentLevel","storageKey","getPersistedLevel","storedLevel","window","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","isSymbol","INFINITY","result","arrayLikeKeys","baseKeys","isArrayLike","isKeyable","map","data","__data__","nativeCreate","getNative","eq","array","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","clear","entry","set","has","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","isEmpty","isEqual","isNull","filter","find","forEach","min","sortBy","iteratee","reIsDeepProp","reIsPlainProp","test","baseForOwn","baseEach","createBaseEach","MAX_SAFE_INTEGER","reIsUint","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","other","baseIsEqualDeep","baseIsEqual","bitmask","customizer","stack","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","Map","collection","isKey","stringToPath","toString","castPath","toKey","path","srcValue","isObject","predicate","resIndex","values","offset","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalFunc","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","push","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","size","func","webpackPolyfill","deprecate","paths","children","funcToString","global","asyncTag","funcTag","genTag","proxyTag","tag","DataView","Promise","Set","WeakMap","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","Ctor","constructor","ctorString","isPrototype","nativeKeys","_loglevel","_interopRequireDefault","_togeojson","_flatten","_","_interopRequireWildcard","Helpers","b","a","getElementsByTagName","parentNode","removeChild","default","kml","features","geometry","_extends","coordinates","reverse","$","ajax","google","maps","LatLng","h","elevation","getGoogleMapsPath","f","parseFloat","g","Math","floor","ElevationService","getElevationAlongPath","samples","ElevationStatus","OK","done","success","error","fail","rbush","meta","featureEach","coordEach","geojsonRbush","maxEntries","tree","insert","feature","bbox","bboxPolygon","turfBBox","load","remove","search","geojson","toBBox","collides","all","toJSON","fromJSON","json","minX","minY","maxX","maxY","lowLeft","topLeft","topRight","properties","Infinity","coord","options","Error","id","validateBBox","validateId","feat","featureCollection","fc","isNumber","num","isNaN","input","main_es_geomEach","callback","j","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","geometries","main_es_flattenEach","geomType","multiFeatureIndex","coordinate","__webpack_exports__","results","main_es_getCoord","main_es_factors","meters","metres","millimeters","main_es_earthRadius","millimetres","centimeters","centimetres","kilometers","kilometres","miles","nauticalmiles","inches","yards","feet","radians","degrees","main_es_radiansToLength","units","factor","main_es_degreesToRadians","PI","main_es_isObject","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","pow","sin","cos","atan2","sqrt","getCoord","containsNumber","getCoords","bearing_bearing","start","end","final","bear","bearing_calculateFinalBearing","degrees2radians","radians2degrees","lon1","lon2","_turf_bearing","invariant_getCoord","invariant_getCoords","invariant_containsNumber","point","lineString","factors","radiansToDistance","_turf_distance","_turf_invariant_getCoord","_turf_invariant_containsNumber","_turf_invariant_getCoords","helpers_feature","helpers_point","helpers_isNumber","helpers_factors","helpers_distanceToRadians","distance","_turf_destination","origin","bearing","longitude1","latitude1","bearing_rad","latitude2","asin","_turf_helpers_feature","_turf_helpers_lineString","_turf_helpers_isNumber","node_modules_turf_invariant_getCoords","node_modules_turf_invariant_containsNumber","geomEach","geometryProperties","flattenEach","meta_feature","featureSubIndex","line_segment","coords","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","line_segment_createSegments","line_segment_lineSegmentFeature","_turf_helpers_featureCollection","line_intersect_node_modules_turf_invariant_getCoords","line_intersect_node_modules_turf_invariant_containsNumber","meta_featureEach","node_modules_turf_helpers_feature","node_modules_turf_helpers_point","node_modules_turf_helpers_isNumber","node_modules_turf_helpers_featureCollection","line_intersect_intersects","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","line_intersect","unique","intersect","geojson_rbush_default","match","join","_turf_meta_geomEach","_turf_meta_flattenEach","node_modules_turf_meta_feature","lines","pt","closestPt","dist","line","sectionLength","heightDistance","max","direction","perpendicularPt1","perpendicularPt2","intersectPt","updateControlColor","removeClass","addClass","updateControlValue","html","Controls","_classCallCheck","_createClass","attr","toFixed","parseInt","Chart","labels","datasets","label","fill","radius","backgroundColor","scales","xAxes","scaleLabel","display","labelString","ticks","yAxes","legend","tooltips","enabled","parent","append","VERIFY_BUTTON_ID","resetElevationChart","routeUrl","routeParamsUrl","routeApproveUrl","polygon","ring","multiLineString","multiPoint","multiPolygon","areaFactors","millimeter","acres","distanceToRadians","geom","geometryCollection","distanceToDegrees","bearingToAngle","angle","convertDistance","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","round","precision","multiplier","excludeWrapCoord","geometryIndex","k","wrapShrink","coordIndex","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureReduce","currentFeature","coordAll","geomReduce","currentGeometry","currentIndex","flattenReduce","segmentEach","segmentIndex","currentSegment","segmentReduce","started","lineEach","subIndex","multi","lineReduce","currentLine","lineIndex","lineSubIndex","swap","arr","tmp","defaultCompare","partialSort","left","right","compare","z","exp","sd","newLeft","newRight","t","quickselect","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","node","distBBox","destNode","createNode","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","mid","pop","_all","len","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","goingUp","indexes","splice","_condense","compareMinX","compareMinY","N","M","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","_pointOnLine","_distance","_helpers","turf","pointOnLine","helpers","CONSTS","Stations","points","pathReversed","pathCircular","pathStart","pathEnd","_sortPoints","_addIndexes","_updateCircularity","_updateDirection","nearestOnLine","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","trim","split","warn","getGain","getLoss","PathElevation","gain","loss","totalChange","_PathElevation","_Stations","Route","geoJson","getLineString","getPoints","isRouteVerifiable","numberOfPaths","getNumberOfFeatures","stations","isPathReversed","reverseLineString","pathElevation","getCount","areAllOnThePath","isOrderCorrect","spherical","computeLength","getPathElevations","then","catch","isIndex","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","constant","baseSetToString","string","writable","setToString","shortOut","thisArg","args","nativeMax","transform","otherArgs","overRest","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","compareAscending","orders","objCriteria","criteria","othCriteria","ordersLength","comparer","arrayMap","baseIteratee","baseMap","baseSortBy","compareMultiple","iteratees","spreadableSymbol","isConcatSpreadable","arrayPush","isFlattenable","baseFlatten","depth","isStrict","baseOrderBy","baseRest","isIterateeCall","comparator","current","computed","baseExtremum","baseLt","arrayEach","castFunction","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","valueOf","replace","isBinary","toNumber","MAX_INTEGER","toFinite","remainder","fromIndex","fromRight","baseFindIndex","toInteger","keys","findIndexFunc","iterable","createFind","baseGet","baseProperty","basePropertyDeep","hasFunc","baseHasIn","hasPath","symbolProto","symbolToString","baseToString","FUNC_ERROR_TEXT","memoize","resolver","memoized","cache","Cache","MAX_MEMOIZE_SIZE","reLeadingDot","rePropName","reEscapeChar","memoizeCapped","number","quote","defaultValue","hasIn","isStrictComparable","matchesStrictComparable","objValue","source","matchData","noCustomizer","baseIsMatch","getMatchData","eachFunc","keysFunc","props","baseFor","createBaseFor","arrayFilter","baseFilter","baseTimes","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","stubArray","nativeGetSymbols","getOwnPropertySymbols","getSymbols","symbol","symbolsFunc","baseGetAllKeys","getAllKeys","objProps","objLength","skipCtor","objCtor","othCtor","Uint8Array","equalArrays","mapToArray","setToArray","boolTag","dateTag","errorTag","mapTag","numberTag","regexpTag","setTag","stringTag","arrayBufferTag","dataViewTag","symbolValueOf","byteLength","byteOffset","buffer","message","convert","HASH_UNDEFINED","setCacheAdd","setCacheHas","add","getMapData","hashClear","hashDelete","hashGet","hashHas","hashSet","Hash","hash","LARGE_ARRAY_SIZE","pairs","assocIndexOf","equalByTag","equalObjects","argsTag","arrayTag","objectTag","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","freeProcess","process","binding","typedArrayTags","coreJsData","uid","maskSrcKey","IE_PROTO","nativeObjectToString","isOwn","unmasked","eval","isMasked","reIsHostCtor","funcProto","reIsNative","RegExp","arg","overArg","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","runClearTimeout","Item","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","cwd","chdir","dir","umask","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","charCodeAt","y","getAttribute","attrf","get1","numarray","nodeVal","el","normalize","textContent","getMulti","ys","coord1","v","coordPair","ll","ele","heartRate","time","xml2str","str","xml","serializeToString","XMLSerializer","doc","gj","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","pairsMap","getPlacemark","kmlColor","color","opacity","substr","gxCoords","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","outline","datas","simpleDatas","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","pointname","pts","heartRates","getProperties","prop","links","link","href","_Route","_Context","_Controls","resetAll","addLoaderToButton","getGeoJSON","isVerifiable","isSinglePath","updateSinglePath","getPathLength","updatePathLength","areAllStationsPresent","updateNumberOfStations","isStationOrderCorrect","updateStationsOrder","areStationsOnThePath","updateStationsOnPath","fetchPathElevationData","getPathElevation","enrichData","updateElevationGain","updateRouteType","updateElevationLoss","updateElevationTotalChange","drawElevationChart","getRouteParameters","ascent","updateDataConsistency","info","approveRoute","reload","modal","always","removeLoaderFromButton"],"mappings":"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","file":"edk-route-verifier.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 176);\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","// Require this file instead of whole lodash library to optimize size of the bundle\r\n\r\nconst isEmpty = require('lodash/isEmpty');\r\nconst isEqual = require('lodash/isEqual');\r\nconst isNull = require('lodash/isNull');\r\nconst filter = require('lodash/filter');\r\nconst find = require('lodash/find');\r\nconst forEach = require('lodash/forEach');\r\nconst map = require('lodash/map');\r\nconst min = require('lodash/min');\r\nconst sortBy = require('lodash/sortBy');\r\n\r\nexport {isEmpty, isEqual, isNull, filter, find, forEach, map, min, sortBy};","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","import logger from 'loglevel';\r\nimport toGeoJSON from 'togeojson';\r\nimport flatten from '@turf/flatten';\r\nimport * as _ from './lodash';\r\n\r\n\r\nexport default class Helpers {\r\n\r\n    static getGeoJSON(kml) {\r\n        const extendedData = kml.getElementsByTagName(\"ExtendedData\");\r\n        for (let index = extendedData.length - 1; index >= 0; index--) {\r\n            extendedData[index].parentNode.removeChild(extendedData[index]);\r\n        }\r\n        logger.log('KML (no ExtendedData):', kml);\r\n\r\n        let geoJson = toGeoJSON.kml(kml);\r\n        geoJson = flatten(geoJson);\r\n        logger.log('GeoJSON (flatten): ', geoJson);\r\n\r\n        return geoJson;\r\n    }\r\n\r\n    static getNumberOfFeatures(featureName, geoJson) {\r\n        const features = _.filter(geoJson.features, feature => {\r\n            return _.isEqual(feature.geometry.type, featureName)\r\n        });\r\n        return features.length;\r\n    }\r\n\r\n    static getLineString(geoJson) {\r\n        const lineString = _.find(geoJson.features, feature => {\r\n            return _.isEqual(feature.geometry.type, 'LineString')\r\n        });\r\n        return lineString;\r\n    }\r\n\r\n    static reverseLineString(lineString) {\r\n        const newLineString = {...lineString};\r\n        newLineString.geometry.coordinates = lineString.geometry.coordinates.reverse();\r\n        return newLineString;\r\n    }\r\n\r\n    static getPoints(geoJson) {\r\n        const points = _.filter(geoJson.features, feature => {\r\n            return _.isEqual(feature.geometry.type, 'Point')\r\n        });\r\n        return points;\r\n    }\r\n\r\n    static getRoute(routeUrl) {\r\n        logger.debug('Fetching route from:', routeUrl);\r\n        return $.ajax(routeUrl);\r\n    }\r\n\r\n    static getGoogleMapsPath(lineString) {\r\n        const path = _.map(lineString.geometry.coordinates, function (element) {\r\n            return new google.maps.LatLng(element[1], element[0]);\r\n        });\r\n        return path;\r\n    }\r\n\r\n    static getPathElevations(lineString, useLocalElevations) {\r\n        if (useLocalElevations && lineString.geometry.coordinates[0].length === 3) {\r\n            // Elevation present in line string\r\n\r\n            logger.debug('Getting path elevations from line string...');\r\n            const elevations = _.map(lineString.geometry.coordinates, element => {\r\n                return {elevation: element[2]};\r\n            });\r\n\r\n            logger.debug('Elevations:', elevations);\r\n            return new Promise((resolve, reject) => {\r\n                resolve(elevations);\r\n            })\r\n        } else {\r\n            // No elevation in line string\r\n            let path = this.getGoogleMapsPath(lineString);\r\n\r\n            // Optimize path array length\r\n            // This is done to send no more than MAXIMUM_NUMBER_OF_LATLNG_OBJECTS coordinates in KML path\r\n            const MAXIMUM_NUMBER_OF_SAMPLES = 512;\r\n            const MAXIMUM_NUMBER_OF_LATLNG_OBJECTS = 1024; // Request to google.maps.ElevationService cannot be too long (2048 is too long)\r\n            logger.debug('Number of LatLng objects:', path.length);\r\n            if (path.length > MAXIMUM_NUMBER_OF_LATLNG_OBJECTS) {\r\n                const optimizedPath = [];\r\n                const delta = parseFloat(path.length / MAXIMUM_NUMBER_OF_LATLNG_OBJECTS);\r\n                for (let i = 0; i < path.length; i = i + delta) {\r\n                    optimizedPath.push(path[Math.floor(i)]);\r\n                }\r\n                path = optimizedPath;\r\n                logger.debug('Number of LatLng objects after optimization:', path.length);\r\n            }\r\n\r\n            return new Promise((resolve,reject) => {\r\n                const elevator = new google.maps.ElevationService;\r\n                elevator.getElevationAlongPath({\r\n                    'path': path,\r\n                    'samples': MAXIMUM_NUMBER_OF_SAMPLES\r\n                }, (elevations, status) => {\r\n                    if (status === google.maps.ElevationStatus.OK) {\r\n                        resolve(elevations);\r\n                    } else {\r\n                        reject(status);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    static getRouteParameters(routeParamsUrl) {\r\n        return new Promise((resolve,reject) => {\r\n            $.ajax(routeParamsUrl)\r\n                .done(data => {\r\n                    logger.debug('Route parameters:', data);\r\n                    if (data.success === 1) {\r\n                        resolve(data);\r\n                    } else {\r\n                        reject('Server side error: ' + data.error);\r\n                    }\r\n                })\r\n                .fail((xhr, status) => {\r\n                    reject(status);\r\n                })\r\n        });\r\n    }\r\n\r\n    static approveRoute(routeApproveUrl) {\r\n        return new Promise((resolve,reject) => {\r\n            $.ajax(routeApproveUrl)\r\n                .done(data => {\r\n                    resolve({success: true});\r\n                })\r\n                .fail((xhr, status) => {\r\n                    reject(status);\r\n                })\r\n        });\r\n    }\r\n}\r\n","var rbush = require('rbush');\nvar meta = require('@turf/meta');\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var rbush = require('geojson-rbush')\n * var tree = rbush()\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { flattenEach } from '@turf/meta';\nimport { featureCollection } from '@turf/helpers';\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {GeoJSON} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = turf.multiPolygon([\n *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n * ]);\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\n\nexport default flatten;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","import { getCoord } from '@turf/invariant';\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Geometry|Feature<Point>|Array<number>} start starting Point\n * @param {Geometry|Feature<Point>|Array<number>} end ending Point\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Backwards compatible with v4.0\n    var final = (typeof options === 'object') ? options.final : options;\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degrees2radians * coordinates1[0];\n    var lon2 = degrees2radians * coordinates2[0];\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var bear = radians2degrees * Math.atan2(a, b);\n\n    return bear;\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","import { getCoord } from '@turf/invariant';\nimport { radiansToDistance } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Geometry|Feature<Point>|Array<number>} from origin point\n * @param {Geometry|Feature<Point>|Array<number>} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n *\n * var distance = turf.distance(from, to, \"miles\");\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);\n    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\nimport { getCoord } from '@turf/invariant';\nimport { point, distanceToRadians } from '@turf/helpers';\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Geometry|Feature<Point>|Array<number>} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} options Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var units = 'miles';\n *\n * var destination = turf.destination(point, distance, bearing, units);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degrees2radians * coordinates1[0];\n    var latitude1 = degrees2radians * coordinates1[1];\n    var bearing_rad = degrees2radians * bearing;\n\n    var radians = distanceToRadians(distance, units);\n\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radians2degrees * longitude2, radians2degrees * latitude2]);\n}\n\nexport default destination;\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","import { lineString, featureCollection } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { point, featureCollection, feature } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { point, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name pointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.pointOnLine(line, pt, 'miles');\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction pointOnLine(lines, pt, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, units);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, units);\n            // sectionLength\n            var sectionLength = distance(start, stop, units);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n            var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, units);\n                intersectPt.properties.location = length + distance(start, intersectPt, units);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default pointOnLine;\n","import logger from 'loglevel';\r\nimport * as _ from './lodash';\r\n\r\n// Constants\r\nconst ROUTE_TYPE_ID = 'div#routeType';\r\nconst SINGLE_PATH_ID = 'div#singlePath';\r\nconst PATH_LENGTH_ID = 'div#pathLength';\r\nconst ELEVATION_GAIN_ID = 'div#elevationGain';\r\nconst ELEVATION_LOSS_ID = 'div#elevationLoss';\r\nconst ELEVATION_TOTAL_CHANGE_ID = 'div#elevationTotalChange';\r\nconst NUMBER_OF_STATIONS_ID = 'div#numberOfStations';\r\nconst STATIONS_ORDER_ID = 'div#stationsOrder';\r\nconst STATIONS_ON_PATH_ID = 'div#stationsOnPath';\r\nconst DATA_CONSISTENCY_ID = 'div#dataConsistency';\r\nconst ELEVATION_CHART_ID = 'canvas#elevationChart';\r\nconst VERIFY_BUTTON_ID = 'button#verifyRoute';\r\nconst LOADER_ID = 'div#loader';\r\nconst LOADER_ELEMENT = '<div id=\"loader\" class=\"overlay\"><i class=\"fa fa-refresh fa-spin\"></i></div>';\r\nconst ELEVATION_CHART_ELEMENT = '<canvas id=\"elevationChart\"></canvas>';\r\n\r\n\r\nconst updateControlColor = function (element, isValid) {\r\n    const VALID_COLOR_CLASS = 'bg-green';\r\n    const INVALID_COLOR_CLASS = 'bg-yellow';\r\n    const INFO_BOX_ICON = 'span.info-box-icon';\r\n\r\n    if (_.isNull(isValid)) {\r\n        $(element + ' ' + INFO_BOX_ICON).removeClass([INVALID_COLOR_CLASS, VALID_COLOR_CLASS].join(' '))\r\n    } else {\r\n        isValid\r\n            ? $(element + ' ' + INFO_BOX_ICON).removeClass(INVALID_COLOR_CLASS).addClass(VALID_COLOR_CLASS)\r\n            : $(element + ' ' + INFO_BOX_ICON).removeClass(VALID_COLOR_CLASS).addClass(INVALID_COLOR_CLASS);\r\n    }\r\n}\r\n\r\nconst updateControlValue = function (element, value, unit) {\r\n    const INFO_BOX_NUMBER = 'span.info-box-number';\r\n\r\n    logger.debug('Updating control element', element, 'with:', value, unit);\r\n    $(element + ' ' + INFO_BOX_NUMBER).html(value + ' ' + (unit ? '<small>'+unit+'</small>' : ''));\r\n}\r\n\r\nconst removeControlChildren = function(element) {\r\n    $(ELEVATION_CHART_ID).empty();\r\n}\r\n\r\n\r\n\r\n\r\nexport default class Controls {\r\n    // Constructor\r\n\r\n\r\n    updateRouteType (isNormalRoute) {\r\n        const normalRouteString = $('input#normalRouteString').attr('value');\r\n        const inspiredRouteString = $('input#inspiredRouteString').attr('value');\r\n        updateControlValue(ROUTE_TYPE_ID, isNormalRoute ? normalRouteString : inspiredRouteString);\r\n    }\r\n\r\n    updatePathLength (isLengthValid, length) {\r\n        updateControlValue(PATH_LENGTH_ID, length.toFixed(2), 'km');\r\n        updateControlColor(PATH_LENGTH_ID, isLengthValid);\r\n    }\r\n\r\n    updateElevationGain (isElevationGainValid, elevationGain) {\r\n        updateControlValue(ELEVATION_GAIN_ID, elevationGain.toFixed(2), 'm')\r\n        updateControlColor(ELEVATION_GAIN_ID, isElevationGainValid);\r\n    }\r\n\r\n    updateElevationLoss (isElevationLossValid, elevationLoss) {\r\n        updateControlValue(ELEVATION_LOSS_ID, elevationLoss.toFixed(2), 'm')\r\n        updateControlColor(ELEVATION_LOSS_ID, isElevationLossValid);\r\n    }\r\n\r\n    updateElevationTotalChange (isElevationTotalChangeValid, elevationTotalChange) {\r\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, elevationTotalChange.toFixed(2), 'm');\r\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isElevationTotalChangeValid);\r\n    }\r\n\r\n    updateNumberOfStations (areAllStationsPresent) {\r\n        updateControlColor(NUMBER_OF_STATIONS_ID, areAllStationsPresent);\r\n    }\r\n\r\n    updateStationsOrder (isStationOrderCorrect) {\r\n        updateControlColor(STATIONS_ORDER_ID, isStationOrderCorrect);\r\n    }\r\n\r\n    updateStationsOnPath (areAllStationsOnPath) {\r\n        updateControlColor(STATIONS_ON_PATH_ID, areAllStationsOnPath);\r\n    }\r\n\r\n    updateSinglePath (isSinglePath) {\r\n        updateControlColor(SINGLE_PATH_ID, isSinglePath);\r\n    }\r\n\r\n    updateDataConsistency (isDataConsistent) {\r\n        updateControlColor(DATA_CONSISTENCY_ID, isDataConsistent);\r\n    }\r\n\r\n     drawElevationChart (pathElevation) {\r\n        const X_AXIS_NUMBER_OF_LABELS = 10;\r\n        const X_AXIS_LABEL_STRING = '[km]';\r\n        const Y_AXIS_LABEL_STRING = '[m]';\r\n        const CHART_BACKGROUND_COLOR = 'rgb(32, 77, 116)';\r\n\r\n        const labelWidth = parseInt(pathElevation.data.length / X_AXIS_NUMBER_OF_LABELS);\r\n        const labels = _.map(pathElevation.data, function(elevation) { return elevation.distance.toFixed(); });\r\n        const data = _.map(pathElevation.data, function(elevation) { return elevation.elevation; }) ;\r\n\r\n        logger.debug('Drawing elevation chart. Input:', pathElevation);\r\n\r\n        const elevationChart = new Chart($(ELEVATION_CHART_ID), {\r\n            type: 'line',\r\n            data: {\r\n                labels: labels,\r\n                datasets: [{\r\n                    label: '',\r\n                    data,\r\n                    fill: 'start',\r\n                    radius: 0,\r\n                    backgroundColor: CHART_BACKGROUND_COLOR\r\n                }]\r\n            },\r\n            options: {\r\n                scales: {\r\n                    xAxes: [{\r\n                        scaleLabel: {\r\n                            display: true,\r\n                            labelString: X_AXIS_LABEL_STRING\r\n                        },\r\n                        ticks: {\r\n                            callback: (dataLabel, index) => {\r\n                                return (index % labelWidth === 0) || (index === pathElevation.data.length-1) ? dataLabel : null;\r\n                            }\r\n                        }\r\n                    }],\r\n                    yAxes: [{\r\n                        scaleLabel: {\r\n                            display: true,\r\n                            labelString: Y_AXIS_LABEL_STRING\r\n                        },\r\n                    }]\r\n                },\r\n                legend: {\r\n                    display: false,\r\n                },\r\n                tooltips: {\r\n                    enabled: false\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    resetElevationChart () {\r\n        const elevationChartParentElement = $(ELEVATION_CHART_ID).parent();\r\n        $(ELEVATION_CHART_ID).remove();\r\n        elevationChartParentElement.append(ELEVATION_CHART_ELEMENT);\r\n    }\r\n\r\n    addLoaderToButton () {\r\n        $(VERIFY_BUTTON_ID).append(LOADER_ELEMENT);\r\n    }\r\n\r\n    removeLoaderFromButton () {\r\n        $(VERIFY_BUTTON_ID + ' ' + LOADER_ID).remove();\r\n    }\r\n\r\n    resetAll (value) {\r\n        const text = '';\r\n        const isValid = value === undefined ? null : value;\r\n\r\n        updateControlValue(ROUTE_TYPE_ID, text);\r\n        updateControlValue(PATH_LENGTH_ID, text);\r\n        updateControlColor(PATH_LENGTH_ID, isValid);\r\n        updateControlValue(ELEVATION_GAIN_ID, text)\r\n        updateControlColor(ELEVATION_GAIN_ID, isValid);\r\n        updateControlValue(ELEVATION_LOSS_ID, text)\r\n        updateControlColor(ELEVATION_LOSS_ID, isValid);\r\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, text);\r\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isValid);\r\n        updateControlColor(NUMBER_OF_STATIONS_ID, isValid);\r\n        updateControlColor(STATIONS_ORDER_ID, isValid);\r\n        updateControlColor(STATIONS_ON_PATH_ID, isValid);\r\n        updateControlColor(SINGLE_PATH_ID, isValid);\r\n        updateControlColor(DATA_CONSISTENCY_ID, isValid);\r\n        this.resetElevationChart();\r\n    }\r\n\r\n}\r\n\r\n","\r\nexport default function() {\r\n    this.routeUrl = $('div#map-canvas').attr('data-what');\r\n    this.routeParamsUrl = $('div#map-canvas').attr('data-route-params');\r\n    this.routeApproveUrl = $('div#map-canvas').attr('data-route-approve');\r\n}\r\n\r\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nfunction lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nfunction featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error('units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error('units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nfunction convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\nmodule.exports = {\n    feature: feature,\n    geometry: geometry,\n    featureCollection: featureCollection,\n    geometryCollection: geometryCollection,\n    point: point,\n    multiPoint: multiPoint,\n    lineString: lineString,\n    multiLineString: multiLineString,\n    polygon: polygon,\n    multiPolygon: multiPolygon,\n    radiansToDistance: radiansToDistance,\n    distanceToRadians: distanceToRadians,\n    distanceToDegrees: distanceToDegrees,\n    radians2degrees: radians2degrees,\n    degrees2radians: degrees2radians,\n    bearingToAngle: bearingToAngle,\n    convertDistance: convertDistance,\n    convertArea: convertArea,\n    round: round,\n    isNumber: isNumber\n};\n","/**\n * GeoJSON BBox\n *\n * @private\n * @typedef {[number, number, number, number]} BBox\n */\n\n/**\n * GeoJSON Id\n *\n * @private\n * @typedef {(number|string)} Id\n */\n\n/**\n * GeoJSON FeatureCollection\n *\n * @private\n * @typedef {Object} FeatureCollection\n * @property {string} type\n * @property {?Id} id\n * @property {?BBox} bbox\n * @property {Feature[]} features\n */\n\n/**\n * GeoJSON Feature\n *\n * @private\n * @typedef {Object} Feature\n * @property {string} type\n * @property {?Id} id\n * @property {?BBox} bbox\n * @property {*} properties\n * @property {Geometry} geometry\n */\n\n/**\n * GeoJSON Geometry\n *\n * @private\n * @typedef {Object} Geometry\n * @property {string} type\n * @property {any[]} coordinates\n */\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nexport function feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nexport function lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","'use strict';\n\nmodule.exports = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","'use strict';\n\nmodule.exports = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import logger from 'loglevel';\r\nimport * as _ from './lodash';\r\nimport pointOnLine from '@turf/point-on-line';\r\nimport distance from '@turf/distance';\r\nimport helpers from '@turf/helpers'\r\nconst turf = {\r\n    pointOnLine,\r\n    distance,\r\n    helpers\r\n};\r\n\r\nconst CONSTS = {\r\n    START_INDEX: 0,\r\n    FIRST_STATION_INDEX: 1,\r\n    LAST_STATION_INDEX: 14,\r\n    END_INDEX: 15\r\n}\r\n\r\n\r\nexport default class Stations {\r\n\r\n    constructor(points, lineString) {\r\n        this.points = points;\r\n        this.path = lineString;\r\n        this.pathReversed = false;\r\n        this.pathCircular = false;\r\n        this.pathStart = turf.helpers.point(this.path.geometry.coordinates[0]);\r\n        this.pathEnd = turf.helpers.point(this.path.geometry.coordinates[this.path.geometry.coordinates.length-1]);\r\n\r\n        this._sortPoints();\r\n        this._addIndexes();\r\n        this._updateCircularity();\r\n        if (!this.pathCircular) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n\r\n    _sortPoints () {\r\n        const path = this.path;\r\n        const enhancedPoints = _.map(this.points, point => {\r\n            point.properties.nearestOnLine = turf.pointOnLine(path, point, 'meters');\r\n            return point;\r\n        });\r\n\r\n        const sortedPoints = _.sortBy(enhancedPoints, point => {\r\n            return point.properties.nearestOnLine.properties.location;\r\n        })\r\n\r\n        this.points = sortedPoints;\r\n    }\r\n\r\n    _addIndexes () {\r\n        const getIndex = str => {\r\n            const START_NAMES_REGEX = /^(wstp|wprowadzenie|pocztek|start)$/ig;\r\n            const END_NAMES_REGEX = /^(zakoczenie|koniec|podsumowanie)$/ig;\r\n            const ROMAN_NUMBERS_REGEX = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV)$/g;\r\n            const EUROPEAN_NUMBERS_REGEX = /^\\d+$/g;\r\n            const SPLITTER_REGEX = /[ ,\\._\\-:;]+/;\r\n            const ROMAN_EUROPEAN_MAP = {\r\n                'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5, 'VI': 6, 'VII': 7,\r\n                'VIII': 8, 'IX': 9, 'X': 10, 'XI': 11, 'XII': 12, 'XIII': 13, 'XIV': 14\r\n            };\r\n\r\n            let index = null;\r\n\r\n            logger.debug('Checking station index for string: ' + str);\r\n\r\n            // noname station\r\n            if (!str) {\r\n                return index;\r\n            }\r\n\r\n            // split\r\n            const parts = str.trim().split(SPLITTER_REGEX);\r\n\r\n            _.forEach(parts, function (part) {\r\n                // try roman numbers\r\n                let matches = part.match(ROMAN_NUMBERS_REGEX); // it isn't clear why there are for matches declaration\r\n                if (!_.isNull(matches)) {\r\n                    index = ROMAN_EUROPEAN_MAP[matches[0]];\r\n                    return false;\r\n                }\r\n\r\n                // try european numbers\r\n                matches = part.match(EUROPEAN_NUMBERS_REGEX);\r\n                if (!_.isNull(matches)) {\r\n                    const stationNumber = parseInt(matches[0]);\r\n                    if (stationNumber >= CONSTS.FIRST_STATION_INDEX && stationNumber <= CONSTS.LAST_STATION_INDEX) {\r\n                        index = stationNumber;\r\n                        return false;\r\n                    } else {\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                // try start names\r\n                matches = part.match(START_NAMES_REGEX);\r\n                if (!_.isNull(matches)) {\r\n                    index = CONSTS.START_INDEX;\r\n                    return false;\r\n                }\r\n\r\n                // try end names\r\n                matches = part.match(END_NAMES_REGEX);\r\n                if (!_.isNull(matches)) {\r\n                    index = CONSTS.END_INDEX;\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            return index;\r\n        }\r\n\r\n        this.points = _.map(this.points, function (point) {\r\n            const name = point.properties.name;\r\n            const number = getIndex(name);\r\n\r\n            point.properties.index = number;\r\n            return point;\r\n        });\r\n    }\r\n\r\n    _updateDirection () {\r\n        const pathReversed = false;\r\n\r\n        const startPoint = _.filter(this.points, point => {\r\n            return point.properties.index === CONSTS.START_INDEX;\r\n        })\r\n        const endPoint = _.filter(this.points, point => {\r\n            return point.properties.index === CONSTS.END_INDEX;\r\n        })\r\n        const options = {units: 'kilometers'};\r\n\r\n        if (!_.isEmpty(startPoint)) {\r\n            logger.debug('Start point detected. Checking if it is closer to path start or path end...');\r\n            const startPointToPathStartDistance = turf.distance(this.pathStart, startPoint[0], options);\r\n            const startPointToPathEndDistance = turf.distance(this.pathEnd, startPoint[0], options);\r\n            if (startPointToPathStartDistance > startPointToPathEndDistance) {\r\n                logger.debug('Reversed path detected. Start point is closer to path end.');\r\n                this.pathReversed = true;\r\n            }\r\n        } else if (!_.isEmpty(endPoint)) {\r\n            logger.debug('End point detected. Checking if it is closer to path start or path end...');\r\n            const endPointToPathStartDistance = turf.distance(this.pathStart, endPoint[0], options);\r\n            const endPointToPathEndDistance = turf.distance(this.pathEnd, endPoint[0], options);\r\n            if (endPointToPathEndDistance > endPointToPathStartDistance) {\r\n                logger.debug('Reversed path detected. Start point is closer to path end.');\r\n                this.pathReversed = true;\r\n            }\r\n        }\r\n        if (this.pathReversed) {\r\n            logger.debug('Reversing points.');\r\n            this.points = this.points.reverse();\r\n        }\r\n    }\r\n\r\n    _updateCircularity () {\r\n        const MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH = 500; // meters\r\n        const options = {units: 'kilometers'};\r\n\r\n        let distance = turf.distance(this.pathStart, this.pathEnd, options);\r\n        distance = distance*1000;\r\n\r\n        if (distance <= MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH) {\r\n            logger.debug('Circular path detected. Distance between path start and end points:', distance.toFixed(2), 'meters.');\r\n            this.pathCircular = true;\r\n        }\r\n    }\r\n\r\n    getCount () {\r\n        let numberOfStations = 0;\r\n        for (let stationNumber = CONSTS.FIRST_STATION_INDEX; stationNumber <= CONSTS.LAST_STATION_INDEX; stationNumber++) {\r\n            let firstStationName = '';\r\n            let stationsOfNumber = _.filter(this.points, function (station) {\r\n                if (station.properties.index === stationNumber) {\r\n                    firstStationName = station.properties.name;\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n            if (stationsOfNumber.length !== 1) {\r\n                logger.warn('Station ' + stationNumber + ' found ' + stationsOfNumber.length + ' times.');\r\n            } else {\r\n                logger.debug('Station ' + stationNumber + ' found. Station name: ' + firstStationName);\r\n                numberOfStations++;\r\n            }\r\n        }\r\n        return numberOfStations;\r\n    }\r\n\r\n    isOrderCorrect () {\r\n        let result = true;\r\n        for(let i = 1; i < this.points.length; i++) {\r\n            const currentStationNumber = this.points[i].properties.index;\r\n            const previousStationNumber = this.points[i-1].properties.index;\r\n            logger.debug('Point ' + (i-1));\r\n            if (currentStationNumber === null) {\r\n                logger.debug('Not checking order for unrecognized point: ' + this.points[i].properties.name);\r\n            } else if (previousStationNumber === null) {\r\n                logger.debug('Not checking order for unrecognized point: ' + this.points[i-1].properties.name);\r\n            } else if (this.pathCircular &&\r\n                (\r\n                    (previousStationNumber === CONSTS.FIRST_STATION_INDEX && currentStationNumber === CONSTS.LAST_STATION_INDEX) ||\r\n                    (currentStationNumber === CONSTS.FIRST_STATION_INDEX && previousStationNumber === CONSTS.LAST_STATION_INDEX)\r\n                )\r\n            )\r\n            {\r\n                logger.debug('Not checking order for station', CONSTS.FIRST_STATION_INDEX, 'and', CONSTS.LAST_STATION_INDEX, 'when route is circular.');\r\n            } else if (currentStationNumber <= previousStationNumber) {\r\n                logger.warn('Detected invalid order of stations. Station ' + currentStationNumber + ' is after station ' + previousStationNumber + '.');\r\n                result = false;\r\n            } else {\r\n                logger.debug('Station ' + currentStationNumber + ' is after station ' + previousStationNumber + '.');\r\n            }\r\n        }\r\n        return result\r\n    }\r\n\r\n    areAllOnThePath (maximumDistanceFromPath) {\r\n        let result = true;\r\n\r\n        _.forEach(this.points, (station, index) => {\r\n            const stationNumber = station.properties.index;\r\n            const distanceFromStationToPath = station.properties.nearestOnLine.properties.dist;\r\n            logger.debug('Point ' + index);\r\n            if (stationNumber === null) {\r\n                logger.debug('Not checking distance for: ' + station.properties.name);\r\n            } else if (distanceFromStationToPath > maximumDistanceFromPath) {\r\n                logger.warn('Station ' + stationNumber + ' is too far from path. Expected maximum distance from path: ' + maximumDistanceFromPath + ' meter(s).');\r\n                result = false;\r\n            } else {\r\n                logger.debug('Station ' + stationNumber + ' is on the path.');\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    isPathReversed () {\r\n        return this.pathReversed;\r\n    }\r\n\r\n}\r\n\r\n","const getGain = elevations => {\r\n    let elevationGain = 0.0;\r\n    for(let i = 1; i < elevations.length; i++) {\r\n        const elevationDifference = elevations[i].elevation - elevations[i-1].elevation;\r\n        elevationGain += (elevationDifference > 0) ? elevationDifference : 0.0;\r\n    }\r\n    return Number(elevationGain);\r\n}\r\n\r\nconst getLoss = elevations => {\r\n    let elevationLoss = 0.0;\r\n    for(let i = 1; i < elevations.length; i++) {\r\n        const elevationDifference = elevations[i-1].elevation - elevations[i].elevation;\r\n        elevationLoss += (elevationDifference > 0) ? elevationDifference : 0.0;\r\n    }\r\n    return Number(elevationLoss);\r\n}\r\n\r\n\r\n\r\nexport default class PathElevation {\r\n    constructor(elevations, length) {\r\n        this.gain = getGain(elevations);\r\n        this.loss = getLoss(elevations);\r\n        this.totalChange = this.loss + this.gain;\r\n        this.data = elevations;\r\n    }\r\n\r\n    enrichData (length) {\r\n        const elevationsWithDistance = [];\r\n        const resolution = length / this.data.length;\r\n        for(let i = 0; i < this.data.length; i++) {\r\n            elevationsWithDistance.push({elevation: this.data[i].elevation, distance: i * resolution});\r\n        }\r\n        this.data = elevationsWithDistance;\r\n    }\r\n}\r\n\r\n\r\n\r\n","import logger from 'loglevel';\r\nimport * as _ from './lodash';\r\nimport helpers from './helpers';\r\nimport PathElevation from './PathElevation';\r\nimport Stations from './Stations';\r\n\r\n// Constants\r\nconst EXPECTED_NUMBER_OF_PATHS = 1;\r\nconst EXPECTED_NUMBER_OF_STATIONS = 14;\r\nconst MAXIMUM_DISTANCE_FROM_STATION_TO_PATH = 100; // meters\r\n\r\n\r\nexport default class Route {\r\n\r\n    constructor (geoJson) {\r\n\r\n        this.geoJson = geoJson;\r\n        this.lineString = helpers.getLineString(this.geoJson);\r\n        this.points = helpers.getPoints(this.geoJson);\r\n        this.isRouteVerifiable = true;\r\n        this.numberOfPaths = helpers.getNumberOfFeatures('LineString', this.geoJson);\r\n        this.stations = new Stations(this.points, this.lineString);\r\n        this.path = this.stations.isPathReversed() ? helpers.reverseLineString(this.lineString) : this.lineString;\r\n        this.pathElevation;\r\n\r\n        /**\r\n         * I'm not sure if this is the right way to implement these checks\r\n         * As I understand, the return statement in the last one will make no effect on further code,\r\n         * While it should somehow stop execution of code with the constructor function implementation\r\n         */\r\n        if(_.isEmpty(this.lineString)) {\r\n            logger.error('No line string in route.');\r\n            this.isRouteVerifiable = false;\r\n        }\r\n        if(_.isEmpty(this.points)) {\r\n            logger.error('No points in route.');\r\n            this.isRouteVerifiable = false;\r\n        }\r\n        if(!this.isRouteVerifiable) {\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n    isVerifiable () {\r\n        return this.isRouteVerifiable;\r\n    }\r\n\r\n    isSinglePath () {\r\n        const result = _.isEqual(this.numberOfPaths, EXPECTED_NUMBER_OF_PATHS);\r\n        logger.debug('isSinglePath:', result, ', numberOfPaths:', this.numberOfPaths);\r\n        return result;\r\n    }\r\n\r\n    areAllStationsPresent () {\r\n        const numberOfStations = this.stations.getCount();\r\n        const result = _.isEqual(numberOfStations, EXPECTED_NUMBER_OF_STATIONS);\r\n        logger.debug('areAllStationsPresent:', result,', numberOfStations:', numberOfStations);\r\n        return result;\r\n    }\r\n\r\n    areStationsOnThePath () {\r\n        const result = this.stations.areAllOnThePath(MAXIMUM_DISTANCE_FROM_STATION_TO_PATH);\r\n        logger.debug('areStationsOnThePath:', result);\r\n        return result;\r\n    }\r\n\r\n    isStationOrderCorrect () {\r\n        const result = this.stations.isOrderCorrect();\r\n        logger.debug('isStationOrderCorrect:', result);\r\n        return result;\r\n    }\r\n\r\n    getPathLength () {\r\n        let result = 0;\r\n\r\n        const googleMapsPath = helpers.getGoogleMapsPath(this.path);\r\n        result = google.maps.geometry.spherical.computeLength(googleMapsPath);\r\n        result = result / 1000;\r\n\r\n        logger.debug('getPathLength [km]:', result);\r\n        return result;\r\n    }\r\n\r\n    fetchPathElevationData () {\r\n        return helpers.getPathElevations(this.path)\r\n            .then(elevations => {\r\n                logger.debug('Path elevations:', elevations);\r\n                this.pathElevation = new PathElevation(elevations);\r\n                return this.pathElevation;\r\n            })\r\n            .catch(error => {\r\n                throw new Error(error);\r\n            });\r\n    }\r\n\r\n\r\n    getPathElevation () {\r\n        logger.debug('getPathElevation:', this.pathElevation);\r\n        return this.pathElevation;\r\n    }\r\n}\r\n\r\n\r\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","/**\n * Checks if `value` is `null`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n * @example\n *\n * _.isNull(null);\n * // => true\n *\n * _.isNull(void 0);\n * // => false\n */\nfunction isNull(value) {\n  return value === null;\n}\n\nmodule.exports = isNull;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym', 'type']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var prop, links;\n                prop = getMulti(node, ['name', 'cmt', 'desc', 'time', 'keywords']);\n                links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n","import logger from 'loglevel';\r\nimport helpers from './helpers';\r\nimport Route from './Route';\r\nimport Context from './Context';\r\nimport Controls from './Controls';\r\n\r\n\r\nfunction verifyRoute() {\r\n    const context = new Context();\r\n    const controls = new Controls();\r\n\r\n    controls.resetAll();\r\n    controls.addLoaderToButton();\r\n\r\n    helpers.getRoute(context.routeUrl)\r\n        .done(data => {\r\n            const geoJson = helpers.getGeoJSON(data);\r\n            const route = new Route(geoJson);\r\n\r\n            if (!route.isVerifiable()) {\r\n                logger.error('Critical error. Route is unverifiable.');\r\n                controls.resetAll(false);\r\n                return;\r\n            }\r\n\r\n            // Path basic checks\r\n            const isSinglePath = route.isSinglePath();\r\n            controls.updateSinglePath(isSinglePath);\r\n\r\n            const routeLength = route.getPathLength();\r\n\r\n            const isPathLengthValid = true;\r\n            controls.updatePathLength(isPathLengthValid, routeLength);\r\n\r\n            // Station checks\r\n            const areAllStationsPresent = route.areAllStationsPresent();\r\n            controls.updateNumberOfStations(areAllStationsPresent);\r\n            const isStationOrderCorrect = route.isStationOrderCorrect();\r\n            controls.updateStationsOrder(isStationOrderCorrect);\r\n            const areStationsOnThePath = route.areStationsOnThePath();\r\n            controls.updateStationsOnPath(areStationsOnThePath);\r\n\r\n            // Elevation checks\r\n            route.fetchPathElevationData()\r\n                .then(() => {\r\n                    const pathElevation = route.getPathElevation();\r\n                    pathElevation.enrichData(routeLength);\r\n\r\n                    const isPathElevationGainValid = true;\r\n                    controls.updateElevationGain(isPathElevationGainValid, pathElevation.gain);\r\n\r\n                    const isNormalRoute = routeLength >= 40 || pathElevation.gain > 500 && routeLength >= 30;\r\n                    controls.updateRouteType(isNormalRoute);\r\n\r\n                    const isPathElevationLossValid = true;\r\n                    controls.updateElevationLoss(isPathElevationLossValid, pathElevation.loss);\r\n\r\n                    const isPathElevationTotalChangeValid = true;\r\n                    controls.updateElevationTotalChange(isPathElevationTotalChangeValid, pathElevation.totalChange);\r\n\r\n                    controls.drawElevationChart(pathElevation);\r\n\r\n                    helpers.getRouteParameters(context.routeParamsUrl)\r\n                        .then(parameters => {\r\n                            const ACCEPTED_ROUTE_LENGTH_DIFF = 1; //km\r\n                            const ACCEPTED_ELEVATION_GAIN_DIFF = 50; //m\r\n                            const NORMAL_ROUTE_TYPE = 0;\r\n                            const INSPIRED_ROUTE_TYPE = 1;\r\n                            \r\n                            const isLengthConsistent = (routeLength - ACCEPTED_ROUTE_LENGTH_DIFF <= parameters.length &&\r\n                                                      parameters.length <= routeLength + ACCEPTED_ROUTE_LENGTH_DIFF);\r\n                            const isElevationGainConsistent = (pathElevation.gain - ACCEPTED_ELEVATION_GAIN_DIFF <= parameters.ascent &&\r\n                                                             parameters.ascent <= pathElevation.gain + ACCEPTED_ELEVATION_GAIN_DIFF);\r\n                            const isRouteTypeConsistent = parameters.type === (isNormalRoute ? NORMAL_ROUTE_TYPE : INSPIRED_ROUTE_TYPE);\r\n                            const isDataConsistent = isLengthConsistent && isElevationGainConsistent && isRouteTypeConsistent;\r\n                            \r\n                            logger.debug('isLengthConsistent:', isLengthConsistent,\r\n                                         ', isElevationGainConsistent:', isElevationGainConsistent,\r\n                                         ', isRouteTypeConsistent:', isRouteTypeConsistent); \r\n                            controls.updateDataConsistency(isDataConsistent);\r\n\r\n                            const canRouteBeAutomaticallyApproved =\r\n                                isPathLengthValid && isPathLengthValid && \r\n                                areAllStationsPresent && isStationOrderCorrect && areStationsOnThePath && \r\n                                isPathElevationGainValid && isPathElevationLossValid && isPathElevationTotalChangeValid &&\r\n                                isDataConsistent;\r\n                            \r\n                            if (canRouteBeAutomaticallyApproved) {\r\n                                logger.info('Route verification success. Approving...');\r\n                                helpers.approveRoute(context.routeApproveUrl)\r\n                                    .then(() => {\r\n                                        logger.info('Route approved.');\r\n                                        const reloadTimeout = setTimeout( () => {\r\n                                            window.location.reload(1);\r\n                                        }, 5000);\r\n                                        $('div#pageReloadModal').on('hide.bs.modal', e => {\r\n                                            clearTimeout(reloadTimeout);\r\n                                        });\r\n                                        $('div#pageReloadModal').modal();\r\n\r\n                                    })\r\n                                    .catch(error => {\r\n                                        logger.error('Route approval error.', error);\r\n                                    })\r\n                            } else {\r\n                                logger.info('Route verification failed. Cannot be approved.');\r\n                            }\r\n                        })\r\n                        .catch(error => {\r\n                            logger.error('Route parameters data fetching error.', error);\r\n                        })\r\n                })\r\n                .catch(error => {\r\n                    logger.error('Path elevation data fetching error.', error);\r\n                    controls.updateElevationGain(false, 0);\r\n                    controls.updateElevationLoss(false, 0);\r\n                    controls.updateElevationTotalChange(false, 0);\r\n                    controls.updateDataConsistency(false);\r\n                });\r\n        }).fail((xhr, status) => {\r\n            logger.error('Route fetching error. Status:', status);\r\n        }).always(() => {\r\n            controls.removeLoaderFromButton();\r\n        });\r\n}\r\n\r\nlogger.setLevel('warn');\r\n// Uncomment to set maximum loglevel\r\nlogger.enableAll();\r\n\r\n$(\"button#verifyRoute\").bind(\"click\", verifyRoute);"],"sourceRoot":""}